{"version":3,"file":"maplibre-gl-shader-layer.js","sources":["../src/lib/core/tools.ts","../src/lib/core/Tile.ts","../src/lib/shaders/globe-tile.v.glsl?raw","../src/lib/core/BaseShaderTiledLayer.ts","../src/lib/core/colormap.ts","../src/lib/core/colormapdescriptionlibrary.ts","../src/lib/core/RemoteTileTextureManager.ts","../src/lib/shaders/daylight.f.glsl?raw","../src/lib/layers/DaylightLayer.ts","../src/lib/shaders/dummy-gradient.f.glsl?raw","../src/lib/layers/DummyGradientTiledLayer.ts","../src/lib/shaders/multi-channel-series-tile.f.glsl?raw","../src/lib/layers/MultiChannelSeriesTiledLayer.ts","../src/lib/shaders/texture-tile.f.glsl?raw","../src/lib/layers/TextureTiledLayer.ts"],"sourcesContent":["import maplibregl, { type LngLat, MercatorCoordinate } from \"maplibre-gl\";\n\nexport type TileIndex = {\n  z: number;\n  x: number;\n  y: number;\n};\n\nexport type TileBoundsUnwrapped = {\n  min: TileIndex;\n  max: TileIndex;\n};\n\nexport type TileUnwrappedPosition = {\n  /**\n   * Position in mercator coordinate. Since it's unwrapped, x can be lower then 0 or higher than 1\n   */\n  center: [number, number];\n\n  /**\n   * both height and width, because tiles are square-shaped\n   */\n  size: number;\n};\n\nfunction mercatorToTileIndex(\n  /**\n   * Mercator coordinates (north-west is [0, 0], sourth-east is [1, 1])\n   */\n  position: [number, number],\n  /**\n   * Zoom level\n   */\n  zoom: number,\n  /**\n   * Returns integer tile indices if `true` or floating-point values if `false`\n   */\n  strict = true,\n): TileIndex {\n  const numberOfTilePerAxis = 2 ** zoom;\n\n  const tileIndex: TileIndex = {\n    z: zoom,\n    x: position[0] * numberOfTilePerAxis,\n    y: position[1] * numberOfTilePerAxis,\n  };\n\n  if (strict) {\n    tileIndex.x = Math.floor(tileIndex.x);\n    tileIndex.y = Math.floor(tileIndex.y);\n  }\n\n  return tileIndex;\n}\n\nexport function wgs84ToTileIndex(position: LngLat, zoom: number, strict = true): TileIndex {\n  const merCoord = MercatorCoordinate.fromLngLat(position);\n  return mercatorToTileIndex([merCoord.x, merCoord.y], zoom, strict);\n}\n\n/**\n * Get the tile index\n */\nexport function getTileBoundsUnwrapped(map: maplibregl.Map, z: number): TileBoundsUnwrapped {\n  const bounds = map.getBounds();\n  const nwMerc = maplibregl.MercatorCoordinate.fromLngLat(bounds.getNorthWest());\n  const seMerc = maplibregl.MercatorCoordinate.fromLngLat(bounds.getSouthEast());\n\n  // Y is always in [0, 1]\n  const eps = 0.000001;\n  nwMerc.y = Math.max(nwMerc.y, 0);\n  nwMerc.y = Math.min(nwMerc.y, 1 - eps);\n  seMerc.y = Math.max(seMerc.y, 0);\n  seMerc.y = Math.min(seMerc.y, 1 - eps);\n\n  // Compute unwrapped tile indices for a given z\n  const nwTile = mercatorToTileIndex([nwMerc.x, nwMerc.y], z, true);\n  const seTile = mercatorToTileIndex([seMerc.x, seMerc.y], z, true);\n\n  return {\n    min: {\n      z: z,\n      x: nwTile.x,\n      y: nwTile.y,\n    },\n    max: {\n      z: z,\n      x: seTile.x,\n      y: seTile.y,\n    },\n  };\n}\n\nexport function tileBoundsUnwrappedToTileList(tbu: TileBoundsUnwrapped): TileIndex[] {\n  const allTileIndices: TileIndex[] = [];\n  const z = tbu.min.z;\n\n  for (let y = tbu.min.y; y <= tbu.max.y; y += 1) {\n    for (let x = tbu.min.x; x <= tbu.max.x; x += 1) {\n      allTileIndices.push({ z, x, y });\n    }\n  }\n  return allTileIndices;\n}\n\nexport function tileIndexToMercatorPosition(ti: TileIndex): TileUnwrappedPosition {\n  const size = 1 / 2 ** ti.z;\n  const centerX = (ti.x + 0.5) * size;\n  const centerY = (ti.y + 0.5) * size;\n  return {\n    size,\n    center: [centerX, centerY],\n  };\n}\n\nexport function wrapTileIndex(tileIndex: TileIndex): TileIndex {\n  const nbTilePerAxis = 2 ** tileIndex.z;\n  let x = tileIndex.x % nbTilePerAxis;\n  if (x < 0) {\n    x = nbTilePerAxis + x;\n  }\n  return {\n    x: x,\n    y: tileIndex.y,\n    z: tileIndex.z,\n  } as TileIndex;\n}\n\nfunction tileIndexToMercatorCenterAndSize(ti: TileIndex): {\n  mercCenter: maplibregl.MercatorCoordinate;\n  mercSize: number;\n} {\n  const nbTiles = 2 ** ti.z;\n  const mercSize = 1 / nbTiles;\n  const mercCenter = new maplibregl.MercatorCoordinate(ti.x * mercSize + mercSize / 2, ti.y * mercSize + mercSize / 2);\n\n  return {\n    mercSize,\n    mercCenter,\n  };\n}\n\n/**\n * Checks if the center and the corners of a tile are visible in viewport\n */\nexport function isTileInViewport(\n  ti: TileIndex,\n  map: maplibregl.Map,\n  mapcanvasWidth: number,\n  mapCanvasHeight: number,\n): boolean {\n  const { mercCenter, mercSize } = tileIndexToMercatorCenterAndSize(ti);\n\n  // using a 5% margin around the\n  const canvasMarginW = mapcanvasWidth * 0.05;\n  const canvasMarginH = mapCanvasHeight * 0.05;\n  const mapCanvasWidthLowerBound = -canvasMarginW;\n  const mapCanvasWidthUpperBound = mapcanvasWidth + canvasMarginW;\n  const mapCanvasHeightLowerBound = -canvasMarginH;\n  const mapCanvasHeightUpperBound = mapCanvasHeight + canvasMarginH;\n  let screenPos = map.project(mercCenter.toLngLat());\n\n  if (\n    screenPos.x >= mapCanvasWidthLowerBound &&\n    screenPos.x <= mapCanvasWidthUpperBound &&\n    screenPos.y >= mapCanvasHeightLowerBound &&\n    screenPos.y <= mapCanvasHeightUpperBound\n  ) {\n    return true;\n  }\n\n  const halfMercSize = mercSize / 2;\n  const mercTopLeft = new maplibregl.MercatorCoordinate(mercCenter.x - halfMercSize, mercCenter.y - halfMercSize);\n  screenPos = map.project(mercTopLeft.toLngLat());\n\n  if (\n    screenPos.x >= mapCanvasWidthLowerBound &&\n    screenPos.x <= mapCanvasWidthUpperBound &&\n    screenPos.y >= mapCanvasHeightLowerBound &&\n    screenPos.y <= mapCanvasHeightUpperBound\n  ) {\n    return true;\n  }\n\n  const mercTopRight = new maplibregl.MercatorCoordinate(mercCenter.x + halfMercSize, mercCenter.y - halfMercSize);\n  screenPos = map.project(mercTopRight.toLngLat());\n\n  if (\n    screenPos.x >= mapCanvasWidthLowerBound &&\n    screenPos.x <= mapCanvasWidthUpperBound &&\n    screenPos.y >= mapCanvasHeightLowerBound &&\n    screenPos.y <= mapCanvasHeightUpperBound\n  ) {\n    return true;\n  }\n\n  const mercBottomLeft = new maplibregl.MercatorCoordinate(mercCenter.x - halfMercSize, mercCenter.y + halfMercSize);\n  screenPos = map.project(mercBottomLeft.toLngLat());\n\n  if (\n    screenPos.x >= mapCanvasWidthLowerBound &&\n    screenPos.x <= mapCanvasWidthUpperBound &&\n    screenPos.y >= mapCanvasHeightLowerBound &&\n    screenPos.y <= mapCanvasHeightUpperBound\n  ) {\n    return true;\n  }\n\n  const mercBottomRight = new maplibregl.MercatorCoordinate(mercCenter.x + halfMercSize, mercCenter.y + halfMercSize);\n  screenPos = map.project(mercBottomRight.toLngLat());\n\n  if (\n    screenPos.x >= mapCanvasWidthLowerBound &&\n    screenPos.x <= mapCanvasWidthUpperBound &&\n    screenPos.y >= mapCanvasHeightLowerBound &&\n    screenPos.y <= mapCanvasHeightUpperBound\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function tileBoundsUnwrappedToTileList2(map: maplibregl.Map): TileIndex[] {\n  return (\n    map\n      .coveringTiles({ tileSize: 512 })\n      // .filter(el => el.overscaledZ === zoom)\n      .map((el) => {\n        return {\n          z: el.canonical.z,\n          x: el.canonical.x,\n          y: el.canonical.y,\n        } as TileIndex;\n      })\n  );\n}\n\n/**\n * Modulo function, as opposed to javascript's `%`, which is a remainder.\n * This functions will return positive values, even if the first operand is negative.\n */\nexport function mod(n: number, m: number): number {\n  return ((n % m) + m) % m;\n}\n\n/**\n * Projects a point within a tile to the surface of the unit sphere globe.\n * @param inTileX - X coordinate inside the tile in range [0 .. 8192].\n * @param inTileY - Y coordinate inside the tile in range [0 .. 8192].\n * @param tileIdX - Tile's X coordinate in range [0 .. 2^zoom - 1].\n * @param tileIdY - Tile's Y coordinate in range [0 .. 2^zoom - 1].\n * @param tileIdZ - Tile's zoom.\n * @returns A 3D vector - coordinates of the projected point on a unit sphere.\n */\nexport function projectTileCoordinatesToSphere(\n  inTileX: number,\n  inTileY: number,\n  tileIdX: number,\n  tileIdY: number,\n  tileIdZ: number,\n  nbSections: number,\n): [number, number, number] {\n  // This code could be assembled from 3 fuctions, but this is a hot path for symbol placement,\n  // so for optimization purposes everything is inlined by hand.\n  //\n  // Non-inlined variant of this function would be this:\n  //     const mercator = tileCoordinatesToMercatorCoordinates(inTileX, inTileY, tileID);\n  //     const angular = mercatorCoordinatesToAngularCoordinatesRadians(mercator.x, mercator.y);\n  //     const sphere = angularCoordinatesRadiansToVector(angular[0], angular[1]);\n  //     return sphere;\n  const scale = 1.0 / (1 << tileIdZ);\n  const mercatorX = (inTileX / nbSections) * scale + tileIdX * scale;\n  const mercatorY = (inTileY / nbSections) * scale + tileIdY * scale;\n  const sphericalX = mod(mercatorX * Math.PI * 2.0 + Math.PI, Math.PI * 2);\n  const sphericalY = 2.0 * Math.atan(Math.exp(Math.PI - mercatorY * Math.PI * 2.0)) - Math.PI * 0.5;\n  const len = Math.cos(sphericalY);\n  return [Math.sin(sphericalX) * len, Math.sin(sphericalY), Math.cos(sphericalX) * len];\n}\n\nexport function projectTileCoordinatesToSphereUV(\n  u: number,\n  v: number,\n  tileIdX: number,\n  tileIdY: number,\n  tileIdZ: number,\n): [number, number, number] {\n  // This code could be assembled from 3 fuctions, but this is a hot path for symbol placement,\n  // so for optimization purposes everything is inlined by hand.\n  //\n  // Non-inlined variant of this function would be this:\n  //     const mercator = tileCoordinatesToMercatorCoordinates(inTileX, inTileY, tileID);\n  //     const angular = mercatorCoordinatesToAngularCoordinatesRadians(mercator.x, mercator.y);\n  //     const sphere = angularCoordinatesRadiansToVector(angular[0], angular[1]);\n  //     return sphere;\n  const scale = 1.0 / (1 << tileIdZ);\n  const mercatorX = u * scale + tileIdX * scale;\n  const mercatorY = v * scale + tileIdY * scale;\n  const sphericalX = mod(mercatorX * Math.PI * 2.0 + Math.PI, Math.PI * 2);\n  const sphericalY = 2.0 * Math.atan(Math.exp(Math.PI - mercatorY * Math.PI * 2.0)) - Math.PI * 0.5;\n  const len = Math.cos(sphericalY);\n  return [Math.sin(sphericalX) * len, Math.sin(sphericalY), Math.cos(sphericalX) * len];\n}\n\nexport function clamp(range: [number, number], value: number): number {\n  if (value < range[0]) {\n    return range[0];\n  }\n\n  if (value > range[1]) {\n    return range[1];\n  }\n\n  return value;\n}\n\n/**\n * Get the pixel value in an HTMLImageElement with a nearest neighbor approach.\n * unitPosition is a texture position, meaning in interval [0, 1]\n */\nexport function pickImg(img: HTMLImageElement, unitPosition: [number, number]): Uint8ClampedArray | null {\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = img.width;\n  canvas.height = img.height;\n  const ctx = canvas.getContext(\"2d\");\n\n  if (!ctx) return null;\n\n  const x = Math.floor(unitPosition[0] * img.width);\n  const y = Math.floor(unitPosition[1] * img.height);\n\n  ctx.drawImage(img, 0, 0);\n  return ctx.getImageData(x, y, 1, 1).data;\n}\n","import {\n  type BufferGeometry,\n  type Material,\n  Matrix4,\n  Mesh,\n  type NormalBufferAttributes,\n  Quaternion,\n  Vector3,\n} from \"three\";\nimport type { TileIndex } from \"./tools\";\n\nexport class Tile extends Mesh {\n  private readonly tileIndex: TileIndex = { z: 0, x: 0, y: 0 };\n\n  constructor(\n    geometry: BufferGeometry<NormalBufferAttributes> | undefined,\n    material: Material | Material[] | undefined,\n  ) {\n    super(geometry?.clone(), material);\n    this.matrixAutoUpdate = false;\n    this.matrixWorldAutoUpdate = false;\n  }\n\n  /**\n   * Defines the tile index and position the tile in the mercator space\n   */\n  setTileIndex(ti: TileIndex) {\n    this.tileIndex.x = ti.x;\n    this.tileIndex.y = ti.y;\n    this.tileIndex.z = ti.z;\n  }\n\n  /**\n   * Get the tile index (a copy)\n   */\n  getTileIndex(): TileIndex {\n    return {\n      x: this.tileIndex.x,\n      y: this.tileIndex.y,\n      z: this.tileIndex.z,\n    };\n  }\n\n  /**\n   * Get the tile index as an array\n   */\n  getTileIndexAsArray(): [number, number, number] {\n    return [this.tileIndex.x, this.tileIndex.y, this.tileIndex.z];\n  }\n}\n\nexport function replaceMatrixScale(matrix: Matrix4, newScale: number) {\n  // Create holders for position, quaternion, and scale\n  const position = new Vector3();\n  const quaternion = new Quaternion();\n  const scale = new Vector3();\n\n  // Decompose the original matrix\n  matrix.decompose(position, quaternion, scale);\n\n  // Create a new matrix\n  const newMatrix = new Matrix4();\n\n  // If newScale is a number, convert it to Vector3\n  const scaleVector = typeof newScale === \"number\" ? new Vector3(newScale, newScale, newScale) : newScale;\n\n  // Compose with the new scale\n  newMatrix.compose(position, quaternion, scaleVector);\n\n  return newMatrix;\n}\n","export default \"precision highp float;\\nprecision highp int;\\n\\n#define PI 3.14159265359\\n#define EARTH_RADIUS 6371008.8\\n\\nuniform mat4 modelViewMatrix; // optional\\nuniform mat4 projectionMatrix; // optional\\nuniform vec3 tileIndex; // tile index\\nuniform bool isGlobe;\\nuniform float altitude;\\n\\n// Both position and vPosition are in [-0.5., 0.5.]\\nin vec3 position;\\nin vec2 uv;\\n\\n// This vPositionUnit is in [0., 1.] to make it easier to map textures\\nout vec2 vPositionUnit;\\n\\n// Longitude / latitude in radians: (lon, lat)\\nout highp vec2 vLonLat;\\n\\n\\nvec2 mercatorToLonLat(vec2 mercator) {\\n  float y = mercator.y;\\n  float lon = mercator.x * 360.0 - 180.0;  // degrees\\n  float lat = (2.0 * atan(exp(PI - 2.0 * PI * y)) - PI * 0.5) * 180.0 / PI;  // degrees\\n  return vec2(lon, lat);\\n}\\n\\n\\nvec2 getMercatorCoords(vec2 uv, vec3 tileIndex) {\\n  float scale = 1.0 / float(1 << int(tileIndex.z));\\n  return vec2(\\n    uv.x * scale + tileIndex.x * scale,\\n    uv.y * scale + tileIndex.y * scale\\n  );\\n}\\n\\nvec3 projectTileCoordinatesToSphere(vec2 uv, vec3 tileIndex, out vec2 lonLat) {\\n  vec2 mercator = getMercatorCoords(uv, tileIndex);\\n  lonLat = mercatorToLonLat(mercator);\\n  float sphericalX = mod(mercator.x * PI * 2.0 + PI, PI * 2.0);\\n  float sphericalY = 2.0 * atan(exp(PI - (mercator.y * PI * 2.0))) - PI * 0.5;\\n  float len = cos(sphericalY);\\n\\n  // Add a small offset to make the vertices float above the surface\\n  float altitudeUnit = altitude / EARTH_RADIUS;\\n  return vec3(\\n    sin(sphericalX) * len * (1.0 + altitudeUnit),\\n    sin(sphericalY) * (1.0 + altitudeUnit),\\n    cos(sphericalX) * len * (1.0 + altitudeUnit)\\n  );\\n}\\n\\nvec3 projectTileCoordinatesToMercator(vec2 uv, vec3 tileIndex, out vec2 lonLat) {\\n  vec2 mercator = getMercatorCoords(uv, tileIndex);\\n  lonLat = mercatorToLonLat(mercator);\\n  // Add a small offset to make the vertices float above the surface\\n  float altitudeUnit =  altitude / EARTH_RADIUS / (2. * PI);\\n  return vec3(mercator.x, mercator.y, altitudeUnit);\\n}\\n\\nvoid main()\\t{\\n  vPositionUnit = position.xy + 0.5;\\n  vec2 lonLat;\\n \\n  // Place the vertices of the tile planes (subdivided in many triangles)\\n  // directly in shader using the UV from ThreeJS\\n  vec3 worldPos = isGlobe ? projectTileCoordinatesToSphere(uv, tileIndex, lonLat) : projectTileCoordinatesToMercator(uv, tileIndex, lonLat);\\n  vLonLat = lonLat;\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( worldPos, 1.0 );\\n}\\n\\n\\n\"","import type maplibregl from \"maplibre-gl\";\nimport {\n  Camera,\n  Matrix4,\n  type MeshBasicMaterial,\n  PlaneGeometry,\n  Scene,\n  WebGLRenderer,\n  type RawShaderMaterial,\n} from \"three\";\nimport {\n  type TileIndex,\n  getTileBoundsUnwrapped,\n  tileBoundsUnwrappedToTileList,\n  isTileInViewport,\n  wrapTileIndex,\n} from \"./tools\";\nimport { Tile } from \"./Tile\";\n\n// @ts-ignore\nimport defaultVertexShader from \"../shaders/globe-tile.v.glsl?raw\";\n\n/**\n * Tile stategy to change (integer) zoom level depending on ramping map zoom level.\n * - FLOOR: tileZ = floor(mapZ) => fairly low resolution tile, a tile can take up to most of the viewport\n * - ROUND: tileZ = round(mapZ) => medium resoltuion, tiles are smaller on screen\n * - CEIL: tileZ = ceil(mapZ) => the highest resolution, +1 Z compared to FLOOR\n */\nexport type TileZoomFitting = \"FLOOR\" | \"ROUND\" | \"CEIL\";\n\nexport type Mat4 =\n  | [\n      number,\n      number,\n      number,\n      number,\n      number,\n      number,\n      number,\n      number,\n      number,\n      number,\n      number,\n      number,\n      number,\n      number,\n      number,\n      number,\n    ]\n  | Float32Array;\n\n/**\n * Function to assign a material to a tile Mesh\n */\ntype SetTileMaterialFunction = (tileIndex: TileIndex) => RawShaderMaterial;\n\n/**\n * Function to update the material of a tile Mesh.\n * The matrix is the one matrix provided by MapLibre\n */\ntype UpdateTileMaterialFunction = (tile: Tile, matrix: Mat4) => void | Promise<void>;\n\nexport type BaseShaderTiledLayerOptions = {\n  /**\n   * Default: 0\n   */\n  minZoom?: number;\n\n  /**\n   * Default: 22\n   */\n  maxZoom?: number;\n\n  /**\n   * Default: false\n   * Setting to `true` will create plenty of tiles smaller than optimal size and may\n   * lead to performance issue.\n   */\n  showBelowMinZoom?: boolean;\n\n  /**\n   * Default: true\n   * Beyond the maxZoom, tiles will show enlarged and possibly not great-looking\n   * if too zoomed-in.\n   */\n  showBeyondMaxZoom?: boolean;\n\n  /**\n   * Function to assign a material to a tile Mesh at the moment a new Tile instance needs to be created\n   */\n  onSetTileMaterial: SetTileMaterialFunction;\n\n  /**\n   * Function to update the material of a tile Mesh when a tile is rendered\n   */\n  onTileUpdate?: UpdateTileMaterialFunction;\n\n  tileZoomFitting?: TileZoomFitting;\n\n  /**\n   * Opacity of the layer\n   */\n  opacity?: number;\n};\n\nexport class BaseShaderTiledLayer implements maplibregl.CustomLayerInterface {\n  public id: string;\n  public readonly type = \"custom\";\n  public renderingMode: \"2d\" | \"3d\" = \"3d\";\n  protected map!: maplibregl.Map;\n  protected renderer!: WebGLRenderer;\n  protected camera!: Camera;\n  protected scene!: Scene;\n  // protected tileContainer!: Object3D;\n  protected debugMaterial!: MeshBasicMaterial;\n  protected tileGeometry!: PlaneGeometry;\n  protected minZoom: number;\n  protected maxZoom: number;\n  protected showBelowMinZoom: boolean;\n  protected showBeyondMaxZoom: boolean;\n  protected shouldShowCurrent!: boolean;\n  protected tilePool: Tile[] = [];\n  protected usedTileMap = new Map<string, Tile>();\n  protected unusedTileList: Array<Tile> = [];\n  protected onSetTileMaterial: SetTileMaterialFunction;\n  protected onTileUpdate: UpdateTileMaterialFunction | null = null;\n  private tileZoomFittingFunction: (v: number) => number = Math.floor;\n  protected opacity = 1;\n  protected altitude = 0;\n  protected isVisible = true;\n  protected readonly defaultVertexShader = defaultVertexShader;\n\n  constructor(id: string, options: BaseShaderTiledLayerOptions) {\n    this.id = id;\n    this.initScene();\n    this.minZoom = options.minZoom ?? 0;\n    this.maxZoom = options.maxZoom ?? 22;\n    this.showBelowMinZoom = options.showBelowMinZoom ?? false;\n    this.showBeyondMaxZoom = options.showBeyondMaxZoom ?? true;\n    this.onSetTileMaterial = options.onSetTileMaterial;\n    this.onTileUpdate = options.onTileUpdate ?? null;\n    this.opacity = Math.max(0, Math.min(options.opacity ?? 1, 1));\n\n    if (options && options.tileZoomFitting) {\n      if (options.tileZoomFitting === \"CEIL\") {\n        this.tileZoomFittingFunction = Math.ceil;\n      } else if (options.tileZoomFitting === \"ROUND\") {\n        this.tileZoomFittingFunction = Math.round;\n      }\n    }\n  }\n\n  setVisible(v: boolean) {\n    this.isVisible = v;\n    if (this.map) {\n      this.map.triggerRepaint();\n    }\n  }\n\n  protected initScene() {\n    this.camera = new Camera();\n    this.scene = new Scene();\n    this.tileGeometry = new PlaneGeometry(1, 1, 32, 32);\n  }\n\n  /**\n   * Compute the correct zoom level based on the map zoom level and the provided options.\n   * The returned value is an integer.\n   */\n  protected getAppropriateZoomLevel(): number {\n    const current = this.tileZoomFittingFunction(this.map.getZoom());\n    if (current < this.minZoom) return this.minZoom;\n    if (current > this.maxZoom) return this.maxZoom;\n    return current;\n  }\n\n  protected shouldShow(): boolean {\n    const current = Math.max(0, Math.floor(this.map.getZoom()));\n    if (current < this.minZoom && !this.showBelowMinZoom) return false;\n    if (current > this.maxZoom && !this.showBeyondMaxZoom) return false;\n    return true;\n  }\n\n  onAdd?(map: maplibregl.Map, gl: WebGLRenderingContext | WebGL2RenderingContext): void {\n    this.map = map;\n    this.renderer = new WebGLRenderer({\n      canvas: map.getCanvas(),\n      context: gl,\n      antialias: true,\n      precision: \"highp\",\n    });\n\n    this.renderer.autoClear = false;\n  }\n\n  protected listTilesIndicesForMapBounds() {\n    const mapProjection = this.map.getProjection();\n    const zoom = this.map.getZoom();\n    const isGlobe = mapProjection && mapProjection.type === \"globe\" && zoom < 12;\n\n    const z = this.getAppropriateZoomLevel();\n    const tbu = getTileBoundsUnwrapped(this.map, z);\n    // The candidates are strictly based on axis-align bounding box, so when map is pitched and rotated,\n    // the list of candidates needs to be pruned from all the tiles that are not in viewport\n    let tileIndicesCandidates = tileBoundsUnwrappedToTileList(tbu);\n\n    if (isGlobe) {\n      const tileMap = new Map<string, TileIndex>();\n      for (const tile of tileIndicesCandidates) {\n        const wrappedTile = wrapTileIndex(tile);\n        tileMap.set(`${wrappedTile.x}_${wrappedTile.y}_${wrappedTile.z}`, wrappedTile);\n      }\n\n      tileIndicesCandidates = Array.from(tileMap.values());\n    }\n\n    if (this.map.getZoom() >= z) {\n      return tileIndicesCandidates;\n    }\n\n    const canvas = this.map.getCanvas();\n    const canvasWidth = canvas.clientWidth;\n    const canvasHeight = canvas.clientHeight;\n    const tileIndicesFiltered = tileIndicesCandidates.filter((ti) =>\n      isTileInViewport(ti, this.map, canvasWidth, canvasHeight),\n    );\n\n    return tileIndicesFiltered;\n  }\n\n  onRemove(_map: maplibregl.Map, _gl: WebGLRenderingContext | WebGL2RenderingContext): void {\n    console.warn(\"not implemented yet\");\n  }\n\n  render(_gl: WebGLRenderingContext | WebGL2RenderingContext, options: maplibregl.CustomRenderMethodInput) {\n    if (!this.isVisible) {\n      return;\n    }\n\n    this.shouldShowCurrent = this.shouldShow();\n\n    // Escape if not rendering\n    if (!this.shouldShowCurrent) return;\n\n    // Brute force flush the tile container (Object3D) and refill it with tiles from the pool\n    // this.tileContainer.clear();\n    this.scene.clear();\n    const allTileIndices = this.listTilesIndicesForMapBounds();\n    const tilesToAdd = [];\n    const usedTileMapPrevious = this.usedTileMap;\n    const usedTileMapNew = new Map<string, Tile>();\n\n    for (const element of allTileIndices) {\n      const tileIndex = element;\n      const tileID = `${tileIndex.z}_${tileIndex.x}_${tileIndex.y}`;\n\n      const tile = usedTileMapPrevious.get(tileID);\n      if (tile) {\n        // This tile is already in the pool\n        usedTileMapNew.set(tileID, tile);\n\n        // Removing it from the previous map so that only remains the unused ones\n        usedTileMapPrevious.delete(tileID);\n        this.scene.add(tile);\n\n        if (this.onTileUpdate) {\n          this.onTileUpdate(tile, options.defaultProjectionData.mainMatrix as Mat4);\n        }\n      } else {\n        // This tile is not in the pool\n        tilesToAdd.push(tileIndex);\n      }\n    }\n\n    this.unusedTileList.push(...Array.from(usedTileMapPrevious.values()));\n\n    for (const element of tilesToAdd) {\n      const tileIndex = element;\n      const tileID = `${tileIndex.z}_${tileIndex.x}_${tileIndex.y}`;\n\n      let tile: Tile;\n\n      if (this.unusedTileList.length > 0) {\n        tile = this.unusedTileList.pop() as Tile;\n      } else {\n        const material = this.onSetTileMaterial(tileIndex);\n        tile = new Tile(this.tileGeometry, material);\n      }\n\n      usedTileMapNew.set(tileID, tile);\n      tile.setTileIndex(tileIndex);\n      this.scene.add(tile);\n\n      if (this.onTileUpdate) {\n        this.onTileUpdate(tile, options.defaultProjectionData.mainMatrix as Mat4);\n      }\n    }\n\n    this.usedTileMap = usedTileMapNew;\n\n    // Actual rendering\n    this.camera.projectionMatrix = new Matrix4().fromArray(options.defaultProjectionData.mainMatrix);\n    this.renderer.resetState();\n    this.renderer.render(this.scene, this.camera);\n  }\n\n  setOpacity(opacity: number) {\n    this.opacity = Math.max(0, Math.min(opacity, 1));\n    if (this.map) {\n      this.map.triggerRepaint();\n    }\n  }\n\n  /**\n   * Set the altitude of the layer in meters.\n   * (Only for globe mode)\n   */\n  setAltitude(altitude: number) {\n    this.altitude = Math.max(altitude, 0);\n    if (this.map) {\n      this.map.triggerRepaint();\n    }\n  }\n}\n","import { CanvasTexture } from \"three\";\nimport Color, { type ColorLike } from \"color\";\n\nexport type ColormapDescription = (number | ColorLike)[];\ntype RgbaArray = [number, number, number, number];\nconst TRANSPARENT_BLACK: RgbaArray = [0, 0, 0, 0];\n\ntype ColormapImageCreationOption = {\n  /**\n   * Whether the canvas is a horizontal image (`true`) or vertical image (`false`).\n   * Default: `true`\n   */\n  horizontal?: boolean;\n\n  /**\n   * Width of the canvas if horizontal, or height of the canvas if vertical.\n   * The other dimension is of size 1px.\n   * Default: `250`\n   */\n  size?: number;\n\n  /**\n   * Whether the colormap is rendered as gradient (true) or as classes (false)\n   */\n  gradient?: boolean;\n};\n\nexport class Colormap {\n  private readonly keyPointValues: number[];\n  private readonly rgbColors: RgbaArray[];\n  private readonly minValue: number;\n  private readonly maxValue: number;\n\n  /**\n   * The constructor should not be used to instanciate a Colormap, use Colormap.fromColormapDescription()\n   * factory function instead.\n   */\n  private constructor(colormapDescription: ColormapDescription) {\n    this.minValue = colormapDescription[0] as number;\n    this.maxValue = colormapDescription.at(-2) as number;\n    this.keyPointValues = colormapDescription.filter((_, i) => i % 2 === 0) as number[];\n    this.rgbColors = (colormapDescription.filter((_, i) => i % 2 === 1) as string[]).map((hexColor) =>\n      Colormap.colorToRgba(hexColor),\n    );\n  }\n\n  getRgbColorAt(value: number, gradient = true): RgbaArray {\n    if (value <= this.minValue) {\n      return this.rgbColors[0];\n    }\n\n    if (value >= this.maxValue) {\n      return this.rgbColors.at(-1) as RgbaArray;\n    }\n\n    for (let i = 0; i < this.keyPointValues.length - 1; i += 1) {\n      if (value === this.keyPointValues[i]) {\n        return this.rgbColors[i];\n      }\n\n      const lowerKeyPointValue = this.keyPointValues[i];\n      const upperKeyPointValue = this.keyPointValues[i + 1];\n\n      if (value > lowerKeyPointValue && value < upperKeyPointValue) {\n        const lowerColor = this.rgbColors[i];\n        if (!gradient) {\n          return lowerColor;\n        }\n\n        const upperColor = this.rgbColors[i + 1];\n        const lowerToUpperKeyPointDistance = upperKeyPointValue - lowerKeyPointValue;\n        const lowerKeyPointToValueDistance = value - lowerKeyPointValue;\n        const weightUpper = lowerKeyPointToValueDistance / lowerToUpperKeyPointDistance;\n        const weightLower = 1 - weightUpper;\n\n        return [\n          Math.trunc(lowerColor[0] * weightLower + upperColor[0] * weightUpper),\n          Math.trunc(lowerColor[1] * weightLower + upperColor[1] * weightUpper),\n          Math.trunc(lowerColor[2] * weightLower + upperColor[2] * weightUpper),\n          Math.trunc(lowerColor[3] * weightLower + upperColor[3] * weightUpper),\n        ] as RgbaArray;\n      }\n    }\n\n    // Should not happen\n    return TRANSPARENT_BLACK;\n  }\n\n  /**\n   * Generates a canvas HTML element containing the colormap\n   */\n  createCanvasElement(options: ColormapImageCreationOption = {}): HTMLCanvasElement {\n    const size = options.size ?? 250;\n    const canvas = document.createElement(\"canvas\");\n    const horizontal = options.horizontal ?? true;\n    const gradient = options.gradient ?? true;\n    canvas.width = horizontal ? size : 1;\n    canvas.height = horizontal ? 1 : size;\n    const ctx = canvas.getContext(\"2d\");\n\n    if (!ctx) throw new Error(\"Canvas context is missing\");\n\n    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    const imageDataArray = imageData.data;\n    const valueSpan = this.maxValue - this.minValue;\n    const valueStep = valueSpan / size;\n\n    for (let i = 0; i < size; i += 1) {\n      const color = this.getRgbColorAt(this.minValue + i * valueStep, gradient);\n      imageDataArray[i * 4] = color[0];\n      imageDataArray[i * 4 + 1] = color[1];\n      imageDataArray[i * 4 + 2] = color[2];\n      imageDataArray[i * 4 + 3] = color[3];\n    }\n\n    ctx.putImageData(imageData, 0, 0);\n    return canvas;\n  }\n\n  /**\n   * Create a PNG image Blob that contains the colormap\n   */\n  async createImageBlob(options: ColormapImageCreationOption = {}): Promise<Blob> {\n    const colormapCanvas = this.createCanvasElement(options);\n    return new Promise((resolve, reject) => {\n      colormapCanvas.toBlob((blob: Blob | null) => {\n        if (blob) {\n          resolve(blob);\n        } else {\n          reject(new Error(\"The blob cound not be generated out of the canvas.\"));\n        }\n      }, \"image/png\");\n    });\n  }\n\n  /**\n   * Create an ObjectURL pointing to an in-memory PNG image of the colormap\n   * (convenient to use as a <img> src attribute)\n   */\n  async createImageObjectURL(options: ColormapImageCreationOption = {}): Promise<string> {\n    const colormapImageBlob = await this.createImageBlob(options);\n    return URL.createObjectURL(colormapImageBlob);\n  }\n\n  /**\n   * Get range labels for the colormap.\n   * The minimum is 2 (at start and finish)\n   * if more than 2, then equally spaced in between\n   */\n  getLabels(\n    options: {\n      numberOfLabels?: number;\n      round?: boolean;\n    } = {},\n  ): number[] {\n    const numberOfLabels = options.numberOfLabels ?? 3;\n    const round = options.round ?? true;\n\n    if (numberOfLabels < 2) {\n      throw new Error(\"At least 2 labels.\");\n    }\n\n    let labels = [this.minValue, this.maxValue];\n    const remainingLabels = numberOfLabels - 2;\n\n    if (remainingLabels) {\n      const range = this.maxValue - this.minValue;\n      const labelStep = range / (remainingLabels + 1);\n      for (let i = 1; i < numberOfLabels - 1; i += 1) {\n        labels.push(this.minValue + labelStep * i);\n      }\n    }\n\n    labels.sort((a, b) => a - b);\n\n    if (round) {\n      labels = labels.map(Math.round);\n    }\n\n    return labels;\n  }\n\n  /**\n   * Returns the range on which is defined the colormap\n   */\n  getRange(): { min: number; max: number } {\n    return {\n      min: this.minValue,\n      max: this.maxValue,\n    };\n  }\n\n  /**\n   * Returns a ThreeJS texture representing this colormap\n   */\n  getTexture(options: ColormapImageCreationOption = {}): CanvasTexture {\n    const canvasEl = this.createCanvasElement(options);\n    return new CanvasTexture(canvasEl);\n  }\n\n  /**\n   * Splits the colormap description in two arrays: an array with only the keyPointValues,\n   * and another one with only colors\n   */\n  static split(colormapDescription: ColormapDescription): [unknown[], unknown[]] {\n    return [colormapDescription.filter((_, i) => i % 2 === 0), colormapDescription.filter((_, i) => i % 2 === 1)];\n  }\n\n  /**\n   * @returns true if the colormap description is valid, false otherwise.\n   */\n  static isColormapDescriptionValid(colormapDescription: ColormapDescription): boolean {\n    // Must be an array\n    if (!Array.isArray(colormapDescription)) {\n      return false;\n    }\n\n    // Must have an even size\n    if (colormapDescription.length % 2 === 1) {\n      return false;\n    }\n\n    // Must contain at least 4 elements\n    if (colormapDescription.length < 4) {\n      return false;\n    }\n\n    const [keyPointValues, colors] = Colormap.split(colormapDescription);\n    const allKeyPointValuesAreNumbers = keyPointValues.every((val) => typeof val === \"number\");\n\n    const allColorsAreHex = colors.every((val) => Colormap.isColorValid(val));\n\n    // Must not have duplicates in the keypoint values\n    if (new Set(keyPointValues).size !== keyPointValues.length) {\n      return false;\n    }\n\n    return allKeyPointValuesAreNumbers && allColorsAreHex;\n  }\n\n  /**\n   * Factory function that performs some verification before instantiating a Colormap\n   * (the Colormap constructor is private)\n   */\n  static fromColormapDescription(\n    colormapDescription: ColormapDescription,\n    scaling?: { min: number; max: number; reverse?: boolean },\n  ): Colormap {\n    const isValid = Colormap.isColormapDescriptionValid(colormapDescription);\n\n    if (!isValid) {\n      throw new Error(\"The provided colormap description is invalid\");\n    }\n\n    const pairs: Array<[number, string]> = [];\n    for (let i = 0; i < colormapDescription.length; i += 2) {\n      pairs.push([colormapDescription[i] as number, colormapDescription[i + 1] as string]);\n    }\n    pairs.sort((a, b) => a[0] - b[0]);\n\n    if (scaling) {\n      if (scaling.min > scaling.max) {\n        throw new Error(\"Colormap scaling min must be greater than max.\");\n      }\n\n      const currentMin = pairs[0][0];\n      const currentMax = pairs[pairs.length - 1][0];\n      const currentSpan = currentMax - currentMin;\n      const targetSpan = scaling.max - scaling.min;\n\n      if (scaling.reverse === true) {\n        const pairsClone = structuredClone(pairs);\n\n        for (let i = 0; i < pairs.length; i += 1) {\n          const pair = pairs[i];\n          const pairClone = pairsClone[pairsClone.length - 1 - i];\n          pair[0] = ((pair[0] - currentMin) / currentSpan) * targetSpan + scaling.min;\n          pair[1] = pairClone[1];\n        }\n      } else {\n        for (const pair of pairs) {\n          pair[0] = ((pair[0] - currentMin) / currentSpan) * targetSpan + scaling.min;\n        }\n      }\n    }\n\n    const ordered = pairs.flat();\n    return new Colormap(ordered);\n  }\n\n  /**\n   * Returns true if the color is valid, false if not\n   */\n  static isColorValid(color: unknown): boolean {\n    try {\n      Color(color as ColorLike);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /**\n   * Turns any color into a RGBA array (with alpha in [0, 255])\n   */\n  static colorToRgba(color: ColorLike): RgbaArray {\n    try {\n      const colorObj = Color(color);\n      return [\n        Math.floor(colorObj.red()),\n        Math.floor(colorObj.green()),\n        Math.floor(colorObj.blue()),\n        Math.floor(colorObj.alpha() * 255),\n      ];\n    } catch (e) {\n      return TRANSPARENT_BLACK;\n    }\n  }\n}\n","import type { ColormapDescription } from \"./colormap\";\nimport turboColormapData from \"../static/turbo-colormap-description.json\";\n\nconst presureBlueWhiteRed = [\n  940_00,\n  \"#03039c\",\n  990_00,\n  \"#5555FF\",\n  1013_00,\n  \"#FFFFFF\",\n  1025_00,\n  \"#FF5555\",\n  1040_00,\n  \"#630000\",\n];\n\nconst teal = [0, \"#1a4d6b\", 0.25, \"#4a7a9a\", 0.5, \"#8ba8bb\", 0.75, \"#b5c4cd\", 1, \"#f5fbff\"];\n\nconst cloudCoverTransparent = [\n  0,\n  \"rgba(255, 255, 255, 0)\",\n  0.25,\n  \"rgba(255, 255, 255, 0)\",\n  0.5,\n  \"rgba(255, 255, 255, 0.1)\",\n  0.75,\n  \"rgba(255, 255, 255, 0.2)\",\n  0.95,\n  \"rgba(255, 255, 255, 0.4)\",\n  1,\n  \"rgba(255, 255, 255, 0.8)\",\n];\n\n// Homemade colormaps\nconst cream = [0, \"#1a4d6b\", 0.25, \"#2d6a8f\", 0.5, \"#4b8bb5\", 0.75, \"#c9a87c\", 1, \"#f5e6d3\"];\n\nconst lagoon = [0, \"#1a3a5c\", 0.2, \"#2d5f7c\", 0.4, \"#4a8a9c\", 0.6, \"#7ab5ac\", 0.8, \"#b0d8b4\", 1, \"#e8f5d8\"];\n\nconst poison = [0, \"#000917\", 0.07, \"#001940\", 0.52, \"#279165\", 0.76, \"#5BD95B\", 0.9, \"#C6FA9B\", 1, \"#C6FA9B\"];\n\nconst twilight = [\n  0.0,\n  \"#003d5c\",\n  0.05,\n  \"#004d73\",\n  0.1,\n  \"#005d8a\",\n  0.15,\n  \"#006da0\",\n  0.2,\n  \"#1e7db5\",\n  0.25,\n  \"#4a8dc9\",\n  0.3,\n  \"#759ddb\",\n  0.35,\n  \"#9eadeb\",\n  0.4,\n  \"#c5bdf8\",\n  0.45,\n  \"#e0cdf9\",\n  0.5,\n  \"#f5ddf4\",\n  0.55,\n  \"#ffdeec\",\n  0.6,\n  \"#ffdfe5\",\n  0.65,\n  \"#ffe1dd\",\n  0.7,\n  \"#ffe4d6\",\n  0.75,\n  \"#ffe8cf\",\n  0.8,\n  \"#ffecc9\",\n  0.85,\n  \"#fff0c4\",\n  0.9,\n  \"#fff4c0\",\n  0.95,\n  \"#fff8bd\",\n  1.0,\n  \"#fffcbb\",\n];\n\nconst redVelvet = [0, \"#2B0C47\", 0.07, \"#4B1370\", 0.5, \"#DB1616\", 0.93, \"#FFDDAD\", 1, \"#FFF9ED\"];\n\nconst ember = [0, \"#420000\", 0.1, \"#521303\", 0.27, \"#A11B1B\", 0.73, \"#EBD059\", 0.93, \"#b5ffad\", 1, \"#e8ffe6\"];\n\n// Classic colormaps\n\nconst hot = [0, [0, 0, 0], 0.3, [230, 0, 0], 0.6, [255, 210, 0], 1, [255, 255, 255]];\n\nconst spring = [0, [255, 0, 255], 1, [255, 255, 0]];\n\nconst summer = [0, [0, 128, 102], 1, [255, 255, 102]];\n\nconst autumn = [0, [255, 0, 0], 1, [255, 255, 0]];\n\nconst winter = [0, [0, 0, 255], 1, [0, 255, 128]];\n\nconst yiorrd = [\n  0,\n  [128, 0, 38],\n  0.125,\n  [189, 0, 38],\n  0.25,\n  [227, 26, 28],\n  0.375,\n  [252, 78, 42],\n  0.5,\n  [253, 141, 60],\n  0.625,\n  [254, 178, 76],\n  0.75,\n  [254, 217, 118],\n  0.875,\n  [255, 237, 160],\n  1,\n  [255, 255, 204],\n];\n\nconst blackbody = [0, [0, 0, 0], 0.2, [230, 0, 0], 0.4, [230, 210, 0], 0.7, [255, 255, 255], 1, [160, 200, 255]];\n\nconst viridis = [\n  0,\n  [68, 1, 84],\n  0.13,\n  [71, 44, 122],\n  0.25,\n  [59, 81, 139],\n  0.38,\n  [44, 113, 142],\n  0.5,\n  [33, 144, 141],\n  0.63,\n  [39, 173, 129],\n  0.75,\n  [92, 200, 99],\n  0.88,\n  [170, 220, 50],\n  1,\n  [253, 231, 37],\n];\n\nconst inferno = [\n  0,\n  [0, 0, 4],\n  0.13,\n  [31, 12, 72],\n  0.25,\n  [85, 15, 109],\n  0.38,\n  [136, 34, 106],\n  0.5,\n  [186, 54, 85],\n  0.63,\n  [227, 89, 51],\n  0.75,\n  [249, 140, 10],\n  0.88,\n  [249, 201, 50],\n  1,\n  [252, 255, 164],\n];\n\nconst magma = [\n  0,\n  [0, 0, 4],\n  0.13,\n  [28, 16, 68],\n  0.25,\n  [79, 18, 123],\n  0.38,\n  [129, 37, 129],\n  0.5,\n  [181, 54, 122],\n  0.63,\n  [229, 80, 100],\n  0.75,\n  [251, 135, 97],\n  0.88,\n  [254, 194, 135],\n  1,\n  [252, 253, 191],\n];\n\nconst bathymetry = [\n  0,\n  [40, 26, 44],\n  0.13,\n  [59, 49, 90],\n  0.25,\n  [64, 76, 139],\n  0.38,\n  [63, 110, 151],\n  0.5,\n  [72, 142, 158],\n  0.63,\n  [85, 174, 163],\n  0.75,\n  [120, 206, 163],\n  0.88,\n  [187, 230, 172],\n  1,\n  [253, 254, 204],\n];\n\nconst density = [\n  0,\n  [54, 14, 36],\n  0.13,\n  [89, 23, 80],\n  0.25,\n  [110, 45, 132],\n  0.38,\n  [120, 77, 178],\n  0.5,\n  [120, 113, 213],\n  0.63,\n  [115, 151, 228],\n  0.75,\n  [134, 185, 227],\n  0.88,\n  [177, 214, 227],\n  1,\n  [230, 241, 241],\n];\n\nconst salinity = [\n  0,\n  [42, 24, 108],\n  0.13,\n  [33, 50, 162],\n  0.25,\n  [15, 90, 145],\n  0.38,\n  [40, 118, 137],\n  0.5,\n  [59, 146, 135],\n  0.63,\n  [79, 175, 126],\n  0.75,\n  [120, 203, 104],\n  0.88,\n  [193, 221, 100],\n  1,\n  [253, 239, 154],\n];\n\nconst temperature = [\n  0,\n  [4, 35, 51],\n  0.13,\n  [23, 51, 122],\n  0.25,\n  [85, 59, 157],\n  0.38,\n  [129, 79, 143],\n  0.5,\n  [175, 95, 130],\n  0.63,\n  [222, 112, 101],\n  0.75,\n  [249, 146, 66],\n  0.88,\n  [249, 196, 65],\n  1,\n  [232, 250, 91],\n];\n\nconst velocityBlue = [\n  0,\n  [17, 32, 64],\n  0.13,\n  [35, 52, 116],\n  0.25,\n  [29, 81, 156],\n  0.38,\n  [31, 113, 162],\n  0.5,\n  [50, 144, 169],\n  0.63,\n  [87, 173, 176],\n  0.75,\n  [149, 196, 189],\n  0.88,\n  [203, 221, 211],\n  1,\n  [254, 251, 230],\n];\n\n// Turbo is so long it's loaded from an external JSON\nconst turbo: ColormapDescription = [];\nfor (let i = 0; i < turboColormapData.length; i += 1) {\n  const turboStop = turboColormapData[i];\n  turbo.push(i / 256, [~~(turboStop[0] * 255), ~~(turboStop[1] * 255), ~~(turboStop[2] * 255)]);\n}\n\nexport const ColormapDescriptionLibrary = {\n  presureBlueWhiteRed,\n  teal,\n  cloudCoverTransparent,\n  cream,\n  lagoon,\n  poison,\n  twilight,\n  redVelvet,\n  ember,\n  hot,\n  spring,\n  summer,\n  autumn,\n  winter,\n  yiorrd,\n  blackbody,\n  viridis,\n  inferno,\n  magma,\n  bathymetry,\n  density,\n  salinity,\n  temperature,\n  velocityBlue,\n  turbo,\n} as const;\n","import QuickLRU from \"quick-lru\";\nimport { type Texture, TextureLoader } from \"three\";\nimport { type TileIndex, wrapTileIndex } from \"../core/tools\";\n\nexport type TextureManagerOptions = {\n  cacheSize?: number;\n};\n\nexport class RemoteTileTextureManager {\n  private readonly texturePool: QuickLRU<string, Texture>;\n  private readonly unavailableTextures = new Set();\n  private readonly textureLoader = new TextureLoader();\n  private readonly textureInProgress = new Map<string, Texture>();\n\n  constructor(options: TextureManagerOptions = {}) {\n    const cacheSize = options.cacheSize ?? 10000;\n\n    this.texturePool = new QuickLRU<string, Texture>({\n      // should be replaced by gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n      maxSize: cacheSize,\n\n      onEviction(_key: string, value: Texture) {\n        console.log(\"Freeing texture from GPU memory\");\n        value.dispose();\n      },\n    });\n  }\n\n  /**\n   * Get a texture from its z/x/y index\n   * If a tile is already in the cache, it will be retrieved from the cache.\n   * If a texture already failed to be retrieved, it is not trying again.\n   */\n  getTexture(tileIndex: TileIndex, textureUrlPattern: string): Promise<Texture> {\n    return new Promise((resolve, reject) => {\n      const tileIndexWrapped = wrapTileIndex(tileIndex);\n      const textureURL = textureUrlPattern\n        .replace(\"{x}\", tileIndexWrapped.x.toString())\n        .replace(\"{y}\", tileIndexWrapped.y.toString())\n        .replace(\"{z}\", tileIndexWrapped.z.toString());\n\n      // The texture is not existing. An unfruitful attempt was made already\n      if (this.unavailableTextures.has(textureURL)) {\n        return reject(new Error(\"Could not load texture.\"));\n      }\n\n      // The texture is in the pool of already fetched textures\n      if (this.texturePool.has(textureURL)) {\n        resolve(this.texturePool.get(textureURL) as Texture);\n        return;\n      }\n\n      // A request of this texture has already been made but is not finished yet\n      if (this.textureInProgress.has(textureURL)) {\n        resolve(this.textureInProgress.get(textureURL) as Texture);\n        return;\n      }\n\n      const tempTexture = this.textureLoader.load(\n        textureURL,\n\n        (texture) => {\n          texture.flipY = false;\n          this.texturePool.set(textureURL, texture);\n          this.textureInProgress.delete(textureURL);\n          resolve(texture);\n        },\n\n        // onProgress callback currently not supported\n        undefined,\n\n        // onError callback\n        (_err) => {\n          this.unavailableTextures.add(textureURL);\n\n          this.textureInProgress.delete(textureURL);\n\n          reject(new Error(\"Could not load texture.\"));\n        },\n      );\n\n      this.textureInProgress.set(textureURL, tempTexture);\n    });\n  }\n\n  /**\n   * Clear the texture cache\n   */\n  clear() {\n    this.texturePool.clear();\n    this.unavailableTextures.clear();\n  }\n}\n","export default \"precision highp float;\\nprecision highp int;\\n\\n#define PI 3.141592653589793\\n#define RAD (PI / 180.0)\\n\\nuniform float colormapRangeMin;\\nuniform float colormapRangeMax;\\nuniform sampler2D colormapTex;\\nuniform float zoom;\\nuniform vec3 tileIndex;\\nuniform float opacity;\\nuniform float sunCoordRa;\\nuniform float sunCoordDec;\\nuniform float sideralTimeComponent;\\n\\nin vec2 vPositionUnit;\\nin vec2 vLonLat;\\nout vec4 fragColor;\\n\\nfloat getSunAltitude(vec2 lonLat) {\\n    float lng = lonLat.x;\\n    float lat = lonLat.y;\\n    \\n    float lw = RAD * -lng;\\n    float phi = RAD * lat;\\n\\n    // Note: important to decompose this into some trigonometry annoyance so that numerical precision is kept on GPU\\n    // Going from:\\n    // float H = (sideralTimeComponent - lw) - sunCoordRa;\\n    // and\\n    // float cosH = cos(sideralTimeComponent - (lw + sunCoordRa));\\n    // to this:\\n    float cosH = cos(sideralTimeComponent) * cos(lw + sunCoordRa) + sin(sideralTimeComponent) * sin(lw + sunCoordRa);\\n    return asin(sin(phi) * sin(sunCoordDec) + cos(phi) * cos(sunCoordDec) * cosH);\\n}\\n\\n\\n\\n// Scales a value from the colormap range (in real-world unit)\\n// to [0, 1]\\nfloat rescaleToTexture(float realWorldValue) {\\n  return (realWorldValue - colormapRangeMin) / (colormapRangeMax - colormapRangeMin);\\n}\\n\\n// Looks up the colormaps color from a given real world unit\\nvec4 getTextureColor(float realWorldValue) {\\n  float unitPosition = rescaleToTexture(realWorldValue);\\n  return texture(colormapTex, vec2(unitPosition, 0.5));\\n}\\n\\n\\nvoid main()  {\\n  float sunAltitude = getSunAltitude(vLonLat);\\n  float altitudeDeg = sunAltitude * 180.0 / PI; // 90° is zenith, 0° is at horizon level\\n  fragColor = getTextureColor(altitudeDeg);\\n  fragColor.a *= opacity;\\n}\"","/**\n * This is a demo of how to extend ShaderTiledLayer\n * RawShaderTiledLayer is a layer that simply contains a texture per tile\n */\n\nimport { BackSide, GLSL3, RawShaderMaterial, Vector3 } from \"three\";\nimport { type Mat4, BaseShaderTiledLayer } from \"../core/BaseShaderTiledLayer\";\n// @ts-ignore\nimport fragmentShader from \"../shaders/daylight.f.glsl?raw\";\nimport type { TileIndex } from \"../core/tools\";\nimport type { Tile } from \"../core/Tile\";\nimport { Colormap } from \"../core/colormap\";\n\nexport type DaylightLayerOptions = {\n  date?: Date;\n  opacity?: number;\n};\n\n// The following sun calculation are borrowef from Volodymyr Agafonkin's Suncalc library:\n// https://github.com/mourner/suncalc\n// The reasons of not importing the whole library is because only a small part is used here\n// and another part of the logic has been moved to the fragment shader\n\n// Date/time constants\nconst DAY_MS = 1000.0 * 60.0 * 60.0 * 24.0;\nconst J1970 = 2440588.0;\nconst J2000 = 2451545.0;\nconst RAD = Math.PI / 180.0;\n\n// Obliquity of Earth\nconst E = RAD * 23.4397;\n\n// Convert timestamp (seconds) to Julian date\nfunction toJulian(timestamp: number): number {\n  const dateMs = timestamp * 1000.0;\n  return dateMs / DAY_MS - 0.5 + J1970;\n}\n\n// Convert Julian date to days since J2000\nfunction toDays(timestamp: number): number {\n  return toJulian(timestamp) - J2000;\n}\n\nfunction solarMeanAnomaly(d: number): number {\n  return RAD * (357.5291 + 0.98560028 * d);\n}\n\nfunction eclipticLongitude(M: number): number {\n  const C = RAD * (1.9148 * Math.sin(M) + 0.02 * Math.sin(2.0 * M) + 0.0003 * Math.sin(3.0 * M));\n  const P = RAD * 102.9372;\n  return M + C + P + Math.PI;\n}\n\nfunction declination(l: number, b: number): number {\n  return Math.asin(Math.sin(b) * Math.cos(E) + Math.cos(b) * Math.sin(E) * Math.sin(l));\n}\n\nfunction rightAscension(l: number, b: number): number {\n  return Math.atan2(Math.sin(l) * Math.cos(E) - Math.tan(b) * Math.sin(E), Math.cos(l));\n}\n\nfunction sunCoords(d: number): { dec: number; ra: number } {\n  const M = solarMeanAnomaly(d);\n  const L = eclipticLongitude(M);\n  const dec = declination(L, 0.0);\n  const ra = rightAscension(L, 0.0);\n\n  return { dec, ra };\n}\n\nfunction computeSideralTimeComponent(day2YK: number): number {\n  return RAD * (280.16 + 360.9856235 * day2YK);\n}\n\nexport class DaylightLayer extends BaseShaderTiledLayer {\n  private date: Date;\n\n  constructor(id: string, options: DaylightLayerOptions = {}) {\n    const colormap = Colormap.fromColormapDescription([\n      -20,\n      \"rgba(9, 14, 31, 0.9)\",\n      -1.5,\n      \"rgba(9, 14, 31, 0.9)\",\n      0,\n      \"rgba(9, 14, 31, 0.0)\",\n      10,\n      \"rgba(9, 14, 31, 0.0)\",\n    ]);\n\n    super(id, {\n      onSetTileMaterial: (tileIndex: TileIndex) => {\n        const mapProjection = this.map.getProjection();\n\n        const timestamp = +this.date / 1000;\n        const daysJ2K = toDays(timestamp);\n        const { dec, ra } = sunCoords(daysJ2K);\n        const sideralTimeComponent = computeSideralTimeComponent(daysJ2K);\n\n        const material = new RawShaderMaterial({\n          // This automatically adds the top-level instruction:\n          // #version 300 es\n          glslVersion: GLSL3,\n\n          uniforms: {\n            colormapTex: { value: colormap.getTexture({ gradient: true }) },\n            colormapRangeMin: { value: colormap.getRange().min },\n            colormapRangeMax: { value: colormap.getRange().max },\n            zoom: { value: this.map.getZoom() },\n            tileIndex: { value: new Vector3(tileIndex.x, tileIndex.y, tileIndex.z) },\n            isGlobe: { value: mapProjection && mapProjection.type === \"globe\" },\n            date: { value: timestamp },\n            opacity: { value: this.opacity },\n            sunCoordRa: { value: ra },\n            sunCoordDec: { value: dec },\n            sideralTimeComponent: { value: sideralTimeComponent },\n            altitude: { value: this.altitude },\n          },\n\n          vertexShader: this.defaultVertexShader,\n          fragmentShader: fragmentShader,\n          side: BackSide,\n          transparent: true,\n          depthTest: false,\n          // wireframe: true,\n        });\n\n        return material;\n      },\n\n      onTileUpdate: (tile: Tile, _matrix: Mat4) => {\n        (tile.material as RawShaderMaterial).uniforms.zoom.value = this.map.getZoom();\n\n        const timestamp = +this.date / 1000;\n        const daysJ2K = toDays(timestamp);\n        const { dec, ra } = sunCoords(daysJ2K);\n        const sideralTimeComponent = computeSideralTimeComponent(daysJ2K);\n\n        const mapProjection = this.map.getProjection();\n        const tileIndeArray = tile.getTileIndexAsArray();\n        const mat = tile.material as RawShaderMaterial;\n        const zoom = this.map.getZoom();\n        // At z12+, the globe is no longer globe in Maplibre\n        const isGlobe = mapProjection && mapProjection.type === \"globe\" && zoom < 12;\n        mat.uniforms.zoom.value = zoom;\n        mat.uniforms.isGlobe.value = isGlobe;\n        mat.uniforms.opacity.value = this.opacity;\n        mat.uniforms.date.value = timestamp;\n        mat.uniforms.sunCoordRa.value = ra;\n        mat.uniforms.sunCoordDec.value = dec;\n        mat.uniforms.sideralTimeComponent.value = sideralTimeComponent;\n        mat.uniforms.altitude.value = this.altitude;\n        (mat.uniforms.tileIndex.value as Vector3).set(tileIndeArray[0], tileIndeArray[1], tileIndeArray[2]);\n      },\n    });\n\n    this.date = options.date ?? new Date();\n\n    if (options.opacity) {\n      this.setOpacity(options.opacity);\n    }\n  }\n\n  setDate(date: Date) {\n    this.date = date;\n    if (this.map) {\n      this.map.triggerRepaint();\n    }\n  }\n}\n","export default \"precision highp float;\\nprecision highp int;\\n\\nuniform float zoom;\\nin vec3 vPosition;\\nin vec2 vPositionUnit;\\nout vec4 fragColor;\\n\\nvoid main()  {\\n  vec2 tileCenter = vec2(0.5, 0.5);\\n  float distanceToCenter = sqrt(pow(vPositionUnit.x - tileCenter.x, 2.) + pow(vPositionUnit.y - tileCenter.y, 2.));\\n\\n  fragColor = vec4(vPositionUnit.x, vPositionUnit.y, 1., 0.6);\\n\\n\\tfloat radius = fract(zoom + 0.5) / 2.;\\n\\n  if (distanceToCenter < radius) {\\n    fragColor.a = 0.0;\\n  }\\n}\"","/**\n * This is a demo of how to extend ShaderTiledLayer\n * RawShaderTiledLayer is a layer that simply contains a texture per tile\n */\n\nimport { BackSide, GLSL3, RawShaderMaterial, Vector3 } from \"three\";\nimport { type Mat4, BaseShaderTiledLayer } from \"../core/BaseShaderTiledLayer\";\n\n// @ts-ignore\nimport fragmentShader from \"../shaders/dummy-gradient.f.glsl?raw\";\nimport type { TileIndex } from \"../core/tools\";\nimport type { Tile } from \"../core/Tile\";\n\nexport class DummyGradientTiledLayer extends BaseShaderTiledLayer {\n  constructor(id: string) {\n    super(id, {\n      onSetTileMaterial: (tileIndex: TileIndex) => {\n        const mapProjection = this.map.getProjection();\n        const material = new RawShaderMaterial({\n          // This automatically adds the top-level instruction:\n          // #version 300 es\n          glslVersion: GLSL3,\n\n          uniforms: {\n            zoom: { value: this.map.getZoom() },\n            tileIndex: { value: new Vector3(tileIndex.x, tileIndex.y, tileIndex.z) },\n            isGlobe: { value: mapProjection && mapProjection.type === \"globe\" },\n            altitude: { value: this.altitude },\n          },\n\n          vertexShader: this.defaultVertexShader,\n          fragmentShader: fragmentShader,\n          side: BackSide,\n          transparent: true,\n          depthTest: false,\n          // wireframe: true,\n        });\n\n        return material;\n      },\n\n      onTileUpdate: (tile: Tile, _matrix: Mat4) => {\n        (tile.material as RawShaderMaterial).uniforms.zoom.value = this.map.getZoom();\n\n        const mapProjection = this.map.getProjection();\n        const tileIndeArray = tile.getTileIndexAsArray();\n        const mat = tile.material as RawShaderMaterial;\n        const zoom = this.map.getZoom();\n        // At z12+, the globe is no longer globe in Maplibre\n        const isGlobe = mapProjection && mapProjection.type === \"globe\" && zoom < 12;\n\n        mat.uniforms.altitude.value = this.altitude;\n        mat.uniforms.zoom.value = zoom;\n        mat.uniforms.isGlobe.value = isGlobe;\n        (mat.uniforms.tileIndex.value as Vector3).set(tileIndeArray[0], tileIndeArray[1], tileIndeArray[2]);\n      },\n    });\n  }\n}\n","export default \"precision highp float;\\nprecision highp int;\\n\\nuniform sampler2D texBefore;\\nuniform sampler2D texAfter;\\nuniform float opacity;\\nuniform float seriesAxisValueBefore;\\nuniform float seriesAxisValueAfter;\\nuniform float seriesAxisValue;\\nuniform float rasterEncodingPolynomialSlope;\\nuniform float rasterEncodingPolynomialOffset;\\nuniform float colormapRangeMin;\\nuniform float colormapRangeMax;\\nuniform sampler2D colormapTex;\\nin vec2 vPositionUnit;\\nout vec4 fragColor;\\n\\n\\n\\nvec4 cubic(float v){\\n  vec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;\\n  vec4 s = n * n * n;\\n  float x = s.x;\\n  float y = s.y - 4.0 * s.x;\\n  float z = s.z - 4.0 * s.y + 6.0 * s.x;\\n  float w = 6.0 - x - y - z;\\n  return vec4(x, y, z, w) * (1.0/6.0);\\n}\\n\\n// This cubic interpolation was borrowed from https://stackoverflow.com/a/42179924/5885003\\nvec4 textureBicubic(sampler2D tex, vec2 texCoords){\\n  vec2 texSize = vec2(textureSize(tex, 0));\\n  vec2 invTexSize = 1.0 / texSize;\\n\\n  texCoords = texCoords * texSize - 0.5;\\n  vec2 fxy = fract(texCoords);\\n  texCoords -= fxy;\\n  vec4 xcubic = cubic(fxy.x);\\n  vec4 ycubic = cubic(fxy.y);\\n  vec4 c = texCoords.xxyy + vec2 (-0.5, +1.5).xyxy;\\n  vec4 s = vec4(xcubic.xz + xcubic.yw, ycubic.xz + ycubic.yw);\\n  vec4 offset = c + vec4 (xcubic.yw, ycubic.yw) / s;\\n  offset *= invTexSize.xxyy;\\n  vec4 sample0 = texture(tex, offset.xz);\\n  vec4 sample1 = texture(tex, offset.yz);\\n  vec4 sample2 = texture(tex, offset.xw);\\n  vec4 sample3 = texture(tex, offset.yw);\\n  float sx = s.x / (s.x + s.y);\\n  float sy = s.z / (s.z + s.w);\\n\\n  return mix(\\n    mix(sample3, sample2, sx), mix(sample1, sample0, sx)\\n  ,sy);\\n}\\n\\n\\n\\n// Scales a value from the colormap range (in real-world unit)\\n// to [0, 1]\\nfloat rescaleToTexture(float realWorldValue) {\\n  return (realWorldValue - colormapRangeMin) / (colormapRangeMax - colormapRangeMin);\\n}\\n\\n// Looks up the colormaps color from a given real world unit\\nvec4 getTextureColor(float realWorldValue) {\\n  float unitPosition = rescaleToTexture(realWorldValue);\\n  return texture(colormapTex, vec2(unitPosition, 0.5));\\n}\\n\\n\\nfloat getRealWorldValue(sampler2D tex, inout bool isNodata) {\\n  // Testing bicubic texture interpolation, but input data is too\\n  // pixalated to make it worth it\\n  // vec4 texColor = textureBicubic(tex, vPositionUnit);\\n\\n  vec4 texColor = texture(tex, vPositionUnit);\\n\\n  isNodata = (texColor.a == 0.0);\\n\\n  // For this test, we use the define RASTER_ENCODING_CHANNELS to know on what channel\\n  // the value to display is encoded\\n  // those channels will then be addressed as relevantChannels.x .y and .z\\n\\n  float x = 0.;\\n\\n  #if RASTER_ENCODING_NB_CHANNELS == 1\\n    x = texColor.RASTER_ENCODING_CHANNELS * 255.;\\n  #elif RASTER_ENCODING_NB_CHANNELS == 2\\n    vec2 relevantChannels = texColor.RASTER_ENCODING_CHANNELS;\\n    x = (relevantChannels.x * 255.) * 256. + (relevantChannels.y * 255.);\\n  #elif RASTER_ENCODING_NB_CHANNELS == 3\\n    vec3 relevantChannels = texColor.RASTER_ENCODING_CHANNELS;\\n    x = (relevantChannels.x * 255.) * 256. * 256. + (relevantChannels.y * 255.) * 256. + (relevantChannels.z * 255.);\\n  #endif\\n\\n  // The value in real world unit\\n  float y = rasterEncodingPolynomialSlope * x + rasterEncodingPolynomialOffset;\\n  return y;\\n}\\n\\n\\n\\n\\nvoid main()  {\\n  bool texBeforeIsNodata = false;\\n  bool texAfterIsNodata = false;\\n  float realWorldValueBefore = getRealWorldValue(texBefore, texBeforeIsNodata);\\n  float realWorldValueAfter = getRealWorldValue(texAfter, texAfterIsNodata);\\n\\n  if (texBeforeIsNodata || texAfterIsNodata) {\\n    // fragColor = vec4(1., 0., 0., 0.3);\\n    discard;\\n    return;\\n  }\\n\\n  float ratioAfter = seriesAxisValueAfter == seriesAxisValueBefore ? 0.0 : (seriesAxisValue - seriesAxisValueBefore) / (seriesAxisValueAfter - seriesAxisValueBefore);\\n  float interpolatedRealWorldValue = ratioAfter * realWorldValueAfter + (1. - ratioAfter) * realWorldValueBefore;\\n  fragColor = getTextureColor(interpolatedRealWorldValue);\\n  fragColor.a *= opacity; \\n}\"","/**\n * This is a demo of how to extend ShaderTiledLayer\n * TextureTiledLayer is a layer that simply contains a texture per tile\n */\nimport { RawShaderMaterial, GLSL3, Vector3, BackSide } from \"three\";\nimport { type Mat4, BaseShaderTiledLayer } from \"../core/BaseShaderTiledLayer\";\nimport { clamp, pickImg, wgs84ToTileIndex, type TileIndex } from \"../core/tools\";\nimport type { Tile } from \"../core/Tile\";\n// @ts-ignore\nimport fragmentShader from \"../shaders/multi-channel-series-tile.f.glsl?raw\";\nimport type { Colormap } from \"../core/colormap\";\nimport type { LngLat } from \"maplibre-gl\";\nimport { RemoteTileTextureManager } from \"../core/RemoteTileTextureManager\";\n\nexport type Bounds = [number, number, number, number];\nexport type SeriesElement = {\n  /**\n   * Pattern to load individual tiles. Assumed to be at the same location\n   * as this payload, unless starting by \"http://\" or \"https://\"\n   * Example: \"some-tile/{z}/{x}/{y}.webp\"\n   */\n  tileUrlPattern: string;\n\n  /**\n   * Value of this timeset along the dimension that this series defines\n   * (since the element of the series are not required to be all equaly spaced)\n   * Example:a unix timestamp value, an altitude elevation, etc.\n   */\n  seriesAxisValue: number;\n\n  /**\n   * Custom metadata the user can add and that apply to this particular tileset\n   * or \"position\" along this series axis\n   */\n  metadata?: Record<string, unknown>;\n};\n\nexport type RasterEncoding = {\n  /**\n   * The image channels to be used to obtain the raster value\n   */\n  channels: string;\n\n  /**\n   * If equal to 1, the raster value to compute is a scalar (can use 1, 2 or 3 `channels`)\n   * If equal to 2, the raster value to compute is a 2D vector. (must use 2 `channels`)\n   * If equal to 3, the raster value to compute is a 3D vector. (must use 3 `channels`)\n   */\n  vectorDimension?: number;\n\n  /**\n   * This is the \"a\" in \"y = ax + b\",\n   * where:\n   *   \"x\" is the raw value computed from the `channels`\n   *   \"y\" is the value is real world unit (eg. degree celcius)\n   *   \"b\" see below\n   */\n  polynomialSlope: number;\n\n  /**\n   * This is the \"b\" in \"y = ax + b\",\n   * where:\n   *   \"x\" is the raw value computed from the `channels`\n   *   \"y\" is the value is real world unit (eg. degree celcius)\n   *   \"a\" see above\n   */\n  polynomialOffset: number;\n};\n\nexport type MultiChannelSeriesTiledLayerSpecification = {\n  /**\n   * Name of the dataset\n   */\n  name: string;\n\n  /**\n   * Description of the dataset\n   */\n  description?: string;\n\n  /**\n   * Attribution associated to the dataset\n   */\n  attribution?: string[];\n\n  bounds: Bounds;\n\n  crs?: string;\n\n  /**\n   * Minimum zoom level in which tiles are available\n   */\n  minZoom: number;\n\n  /**\n   * Maximum zoom level in which tiles are available\n   */\n  maxZoom: number;\n\n  /**\n   * Size of the tile in pixels (for both width and height)\n   */\n  tileSize: number;\n\n  /**\n   * File format of the tiles. Likely to be png or webp.\n   * (Most likely not jpeg due to lossy compression)\n   */\n  rasterFormat: \"png\" | \"webp\";\n\n  /**\n   * This section is used for decoding the data\n   */\n  rasterEncoding: RasterEncoding;\n\n  /**\n   * The real world unit of the value computed for each pixel.\n   * Could be left empty.\n   */\n  pixelUnit?: string;\n\n  /**\n   * Name to give to the series axis (eg. \"time\", \"depth\", \"altitude\", etc.)\n   */\n  seriesAxisName: string;\n\n  /**\n   * Real world unit of the series axis (eg. \"second\", \"meter\", etc.)\n   */\n  seriesAxisUnit: string;\n\n  /**\n   * Extra metadata the use can add to this tileset and that would apply to\n   * the whole series\n   */\n  metadata?: Record<string, unknown>;\n\n  /**\n   * The series includes all the tilesets in the relevant order\n   */\n  series: SeriesElement[];\n};\n\nexport type MultiChannelSeriesTiledLayerOptions = {\n  datasetSpecification: MultiChannelSeriesTiledLayerSpecification;\n  colormap: Colormap;\n\n  /**\n   * Whether the colormap should be rendered with gradient (true)\n   * or with classes (false)\n   * default: true\n   */\n  colormapGradient?: boolean;\n\n  /**\n   * Position to start with when initializing the layer.\n   * If not provided, the begining of the series will be used instead\n   */\n  seriesAxisValue?: number;\n\n  /**\n   * Prefix to the tile url\n   */\n  tileUrlPrefix?: string;\n\n  /**\n   * A texture manager can be provided. This can be interesting when multiple\n   * layers are using the same textures.\n   * If not provided, a default one will be added internaly to this layer.\n   */\n  remoteTileTextureManager?: RemoteTileTextureManager;\n};\n\nexport class MultiChannelSeriesTiledLayer extends BaseShaderTiledLayer {\n  private readonly rasterEncoding: RasterEncoding;\n  private readonly colormap: Colormap;\n  private seriesAxisValue!: number;\n  private readonly datasetSpecification: MultiChannelSeriesTiledLayerSpecification;\n  private seriesElementBefore!: SeriesElement;\n  private indexSeriesElementBefore = 0;\n  private seriesElementAfter!: SeriesElement;\n  private readonly tileUrlPrefix: string;\n  private readonly colormapGradient;\n  private readonly remoteTileTextureManager: RemoteTileTextureManager;\n\n  constructor(id: string, options: MultiChannelSeriesTiledLayerOptions) {\n    console.log(\"options\", options);\n\n    super(id, {\n      minZoom: options.datasetSpecification.minZoom,\n      maxZoom: options.datasetSpecification.maxZoom,\n\n      onSetTileMaterial: (tileIndex: TileIndex) => {\n        const mapProjection = this.map.getProjection();\n        const material = new RawShaderMaterial({\n          // This automatically adds the top-level instruction:\n          // #version 300 es\n          glslVersion: GLSL3,\n\n          uniforms: {\n            opacity: { value: this.opacity },\n            texBefore: { value: null },\n            texAfter: { value: null },\n            seriesAxisValueBefore: { value: this.seriesElementBefore.seriesAxisValue },\n            seriesAxisValueAfter: { value: this.seriesElementAfter.seriesAxisValue },\n            seriesAxisValue: { value: this.seriesAxisValue },\n            zoom: { value: this.map.getZoom() },\n            tileIndex: { value: new Vector3(tileIndex.x, tileIndex.y, tileIndex.z) },\n            isGlobe: { value: mapProjection && mapProjection.type === \"globe\" },\n            rasterEncodingPolynomialSlope: { value: this.rasterEncoding.polynomialSlope },\n            rasterEncodingPolynomialOffset: { value: this.rasterEncoding.polynomialOffset },\n            colormapRangeMin: { value: this.colormap.getRange().min },\n            colormapRangeMax: { value: this.colormap.getRange().max },\n            colormapTex: {\n              value: this.colormap.getTexture({\n                gradient: this.colormapGradient,\n                size: this.colormapGradient ? 512 : 4096,\n              }),\n            },\n            altitude: { value: this.altitude },\n          },\n          vertexShader: this.defaultVertexShader,\n          fragmentShader: fragmentShader,\n          side: BackSide,\n          transparent: true,\n          depthTest: false,\n          // wireframe: true,\n          defines: {\n            RASTER_ENCODING_CHANNELS: this.rasterEncoding.channels,\n            RASTER_ENCODING_NB_CHANNELS: this.rasterEncoding.channels.length,\n          },\n        });\n\n        return material;\n      },\n\n      onTileUpdate: async (tile: Tile, _matrix: Mat4) => {\n        // TODO: Add a signal to cancel the fetching of the texture in case the series axis moves too fast\n        // and needs to skip/jump further.\n\n        const texBeforeAfter = await Promise.allSettled([\n          this.remoteTileTextureManager.getTexture(\n            tile.getTileIndex(),\n            `${this.tileUrlPrefix}${this.seriesElementBefore.tileUrlPattern}`,\n          ),\n          this.remoteTileTextureManager.getTexture(\n            tile.getTileIndex(),\n            `${this.tileUrlPrefix}${this.seriesElementAfter.tileUrlPattern}`,\n          ),\n        ]);\n\n        const mapProjection = this.map.getProjection();\n        const tileIndeArray = tile.getTileIndexAsArray();\n        const material = tile.material as RawShaderMaterial;\n        const zoom = this.map.getZoom();\n        material.uniforms.opacity.value = this.opacity;\n        // At z12+, the globe is no longer globe in Maplibre\n        const isGlobe = mapProjection && mapProjection.type === \"globe\" && zoom < 12;\n        material.uniforms.texBefore.value = texBeforeAfter[0].status === \"fulfilled\" ? texBeforeAfter[0].value : null;\n        material.uniforms.texAfter.value = texBeforeAfter[1].status === \"fulfilled\" ? texBeforeAfter[1].value : null;\n        material.uniforms.seriesAxisValueBefore.value = this.seriesElementBefore.seriesAxisValue;\n        material.uniforms.seriesAxisValueAfter.value = this.seriesElementAfter.seriesAxisValue;\n        material.uniforms.seriesAxisValue.value = this.seriesAxisValue;\n        material.uniforms.zoom.value = zoom;\n        material.uniforms.isGlobe.value = isGlobe;\n        material.uniforms.altitude.value = this.altitude;\n        (material.uniforms.tileIndex.value as Vector3).set(tileIndeArray[0], tileIndeArray[1], tileIndeArray[2]);\n      },\n    });\n\n    this.colormapGradient = options.colormapGradient ?? true;\n    this.tileUrlPrefix = options.tileUrlPrefix ?? \"\";\n    this.datasetSpecification = options.datasetSpecification;\n    this.rasterEncoding = options.datasetSpecification.rasterEncoding;\n    this.colormap = options.colormap;\n    this.setSeriesAxisValue(options.seriesAxisValue ?? this.datasetSpecification.series[0].seriesAxisValue);\n    this.remoteTileTextureManager = options.remoteTileTextureManager ?? new RemoteTileTextureManager();\n  }\n\n  /**\n   * Get the range of values along the series axis.\n   * It is assumed that the first element of the series has a smaller value\n   * than the last.\n   */\n  private getSerieAxisRange(): [number, number] | null {\n    const series = this.datasetSpecification.series;\n    if (!series.length) {\n      return null;\n    }\n\n    return [series[0].seriesAxisValue, series[series.length - 1].seriesAxisValue];\n  }\n\n  setSeriesAxisValue(pos: number) {\n    const range = this.getSerieAxisRange();\n    if (!range) {\n      return;\n    }\n    this.seriesAxisValue = clamp(range, pos);\n    this.defineCurrentSeriesElement();\n\n    if (this.map) {\n      this.map.triggerRepaint();\n    }\n  }\n\n  getSeriesAxisValue(): number {\n    return this.seriesAxisValue;\n  }\n\n  private defineCurrentSeriesElement() {\n    const series = this.datasetSpecification.series;\n    if (!series.length) {\n      return null;\n    }\n\n    if (series.length === 1) {\n      this.indexSeriesElementBefore = 0;\n      this.seriesElementBefore = series[0];\n      this.seriesElementAfter = series[0];\n      return;\n    }\n\n    const range = this.getSerieAxisRange();\n    if (!range) {\n      return;\n    }\n\n    if (this.seriesAxisValue <= range[0]) {\n      this.indexSeriesElementBefore = 0;\n      this.seriesElementBefore = series[0];\n      this.seriesElementAfter = series[0];\n      return;\n    }\n\n    if (this.seriesAxisValue >= range[1]) {\n      this.indexSeriesElementBefore = series.length - 1;\n      this.seriesElementBefore = series[series.length - 1];\n      this.seriesElementAfter = series[series.length - 1];\n      return;\n    }\n\n    for (let i = 0; i < series.length - 1; i += 1) {\n      const seriesI = series[i];\n      const seriesNext = series[i + 1];\n\n      if (this.seriesAxisValue >= seriesI.seriesAxisValue && this.seriesAxisValue < seriesNext.seriesAxisValue) {\n        this.indexSeriesElementBefore = i;\n        this.seriesElementBefore = seriesI;\n        this.seriesElementAfter = seriesNext;\n        break;\n      }\n    }\n  }\n\n  /**\n   * Prefetch texture along the series dimensions for the same tile coverage as the curent.\n   * deltaBefore is the number of series elements before the curent position and deltaAfter\n   * is the number of elements after the curent position.\n   */\n  async prefetchSeriesTexture(deltaBefore: number, deltaAfter: number) {\n    // Tile indices {x, y, z} of the current tile coverage\n    const tileIndices = Array.from(this.usedTileMap.values()).map((tile) => tile.getTileIndex());\n    const series = this.datasetSpecification.series;\n    const fetchingPromiseList = [];\n\n    const seriesIndexStart = Math.max(0, this.indexSeriesElementBefore + deltaBefore);\n    const seriesIndexEnd = Math.min(series.length - 1, this.indexSeriesElementBefore + deltaAfter);\n\n    let counter = 0;\n\n    for (let i = seriesIndexStart; i < seriesIndexEnd + 1; i += 1) {\n      if (i < 0) continue;\n      if (i >= series.length) break;\n\n      for (const tileIndex of tileIndices) {\n        counter++;\n        fetchingPromiseList.push(\n          this.remoteTileTextureManager.getTexture(tileIndex, `${this.tileUrlPrefix}${series[i].tileUrlPattern}`),\n        );\n      }\n    }\n\n    await Promise.allSettled(fetchingPromiseList);\n  }\n\n  /**\n   * Get the value and unit at a given position, for the current series axis position.\n   */\n  async pick(lngLat: LngLat): Promise<{ value: number; unit: string | undefined } | null> {\n    const tileIndices = Array.from(this.usedTileMap.values()).map((tile) => tile.getTileIndex());\n\n    // Getting zoom level of current displayed tiles\n    const z = tileIndices[0].z;\n\n    const tileToPickUnstrict = wgs84ToTileIndex(lngLat, z, false);\n    const tileIndexStrict = {\n      z,\n      x: Math.floor(tileToPickUnstrict.x),\n      y: Math.floor(tileToPickUnstrict.y),\n    } as TileIndex;\n\n    const texturesBeforeAfter = await Promise.allSettled([\n      await this.remoteTileTextureManager.getTexture(\n        tileIndexStrict,\n        `${this.tileUrlPrefix}${this.seriesElementBefore.tileUrlPattern}`,\n      ),\n      await this.remoteTileTextureManager.getTexture(\n        tileIndexStrict,\n        `${this.tileUrlPrefix}${this.seriesElementAfter.tileUrlPattern}`,\n      ),\n    ]);\n\n    if (texturesBeforeAfter[0].status === \"rejected\" || texturesBeforeAfter[1].status === \"rejected\") {\n      return null;\n    }\n\n    const textureBefore = texturesBeforeAfter[0].value;\n    const textureAfter = texturesBeforeAfter[1].value;\n\n    const textureUnitPosition = [\n      tileToPickUnstrict.x - tileIndexStrict.x,\n      tileToPickUnstrict.y - tileIndexStrict.y,\n    ] as [number, number];\n\n    const valuePixelBefore = pickImg(textureBefore.image, textureUnitPosition);\n    const valuePixelAfter = pickImg(textureAfter.image, textureUnitPosition);\n\n    if (!valuePixelBefore || !valuePixelAfter) return null;\n\n    const channels = Array.from(this.datasetSpecification.rasterEncoding.channels);\n    const valuePixelBeforeObj: Record<string, number> = {\n      r: valuePixelBefore[0],\n      g: valuePixelBefore[1],\n      b: valuePixelBefore[2],\n      a: valuePixelBefore[3],\n    };\n\n    const valuePixelAfterObj: Record<string, number> = {\n      r: valuePixelAfter[0],\n      g: valuePixelAfter[1],\n      b: valuePixelAfter[2],\n      a: valuePixelAfter[3],\n    };\n\n    // Nodata\n    if (valuePixelBeforeObj.a === 0 || valuePixelAfterObj.a === 0) {\n      return null;\n    }\n\n    let encodedValueBefore = 0;\n    let encodedValueAfter = 0;\n\n    if (channels.length === 1) {\n      encodedValueBefore = valuePixelBeforeObj[channels[0]];\n      encodedValueAfter = valuePixelAfterObj[channels[0]];\n    } else if (channels.length === 2) {\n      encodedValueBefore = valuePixelBeforeObj[channels[0]] * 256 + valuePixelBeforeObj[channels[1]];\n      encodedValueAfter = valuePixelAfterObj[channels[0]] * 256 + valuePixelAfterObj[channels[1]];\n    } else if (channels.length === 3) {\n      encodedValueBefore =\n        valuePixelBeforeObj[channels[0]] * 256 * 256 +\n        valuePixelBeforeObj[channels[1]] * 256 +\n        valuePixelBeforeObj[channels[2]];\n      encodedValueAfter =\n        valuePixelAfterObj[channels[0]] * 256 * 256 +\n        valuePixelAfterObj[channels[1]] * 256 +\n        valuePixelAfterObj[channels[2]];\n    } else {\n      return null;\n    }\n\n    const { polynomialOffset, polynomialSlope } = this.datasetSpecification.rasterEncoding;\n    const realWorldValueBefore = encodedValueBefore * polynomialSlope + polynomialOffset;\n    const realWorldValueAfter = encodedValueAfter * polynomialSlope + polynomialOffset;\n    const ratioAfter =\n      this.seriesElementAfter.seriesAxisValue === this.seriesElementBefore.seriesAxisValue\n        ? realWorldValueBefore\n        : (this.seriesAxisValue - this.seriesElementBefore.seriesAxisValue) /\n          (this.seriesElementAfter.seriesAxisValue - this.seriesElementBefore.seriesAxisValue);\n    const realWorldValue = ratioAfter * realWorldValueAfter + (1 - ratioAfter) * realWorldValueBefore;\n\n    return {\n      value: realWorldValue,\n      unit: this.datasetSpecification.pixelUnit,\n    };\n  }\n}\n","export default \"precision highp float;\\nprecision highp int;\\n\\nuniform sampler2D tex;\\nuniform float opacity;\\nin vec2 vPositionUnit;\\nout vec4 fragColor;\\n\\nvoid main()  {\\n  fragColor = texture(tex, vPositionUnit);\\n  fragColor.a *= opacity;\\n\\n}\"","/**\n * This is a demo of how to extend ShaderTiledLayer\n * TextureTiledLayer is a layer that simply contains a texture per tile\n */\n\nimport { RawShaderMaterial, GLSL3, Vector3, BackSide } from \"three\";\nimport { type Mat4, BaseShaderTiledLayer } from \"../core/BaseShaderTiledLayer\";\nimport type { TileIndex } from \"../core/tools\";\nimport type { Tile } from \"../core/Tile\";\nimport { RemoteTileTextureManager } from \"../core/RemoteTileTextureManager\";\n// @ts-ignore\nimport fragmentShader from \"../shaders/texture-tile.f.glsl?raw\";\n\nexport type TextureTiledLayerOptions = {\n  minZoom?: number;\n  maxZoom?: number;\n  textureUrlPattern: string;\n  /**\n   * A texture manager can be provided. This can be interesting when multiple\n   * layers are using the same textures.\n   * If not provided, a default one will be added internaly to this layer.\n   */\n  remoteTileTextureManager?: RemoteTileTextureManager;\n};\n\nexport class TextureTiledLayer extends BaseShaderTiledLayer {\n  private readonly textureUrlPattern: string;\n  private readonly remoteTileTextureManager: RemoteTileTextureManager;\n\n  constructor(id: string, options: TextureTiledLayerOptions) {\n    super(id, {\n      minZoom: options.minZoom ?? 0,\n      maxZoom: options.maxZoom ?? 22,\n\n      onSetTileMaterial: (tileIndex: TileIndex) => {\n        const mapProjection = this.map.getProjection();\n\n        const material = new RawShaderMaterial({\n          // This automatically adds the top-level instruction:\n          // #version 300 es\n          glslVersion: GLSL3,\n\n          uniforms: {\n            tex: { value: null },\n            zoom: { value: this.map.getZoom() },\n            tileIndex: { value: new Vector3(tileIndex.x, tileIndex.y, tileIndex.z) },\n            isGlobe: { value: mapProjection && mapProjection.type === \"globe\" },\n            opacity: { value: this.opacity },\n          },\n          vertexShader: this.defaultVertexShader,\n          fragmentShader: fragmentShader,\n          side: BackSide,\n          transparent: true,\n          depthTest: false,\n          // wireframe: true,\n        });\n\n        return material;\n      },\n\n      onTileUpdate: async (tile: Tile, _matrix: Mat4) => {\n        const mapProjection = this.map.getProjection();\n        const tileIndeArray = tile.getTileIndexAsArray();\n        const mat = tile.material as RawShaderMaterial;\n        const zoom = this.map.getZoom();\n        // At z12+, the globe is no longer globe in Maplibre\n        const isGlobe = mapProjection && mapProjection.type === \"globe\" && zoom < 12;\n        mat.uniforms.tex.value = await this.remoteTileTextureManager.getTexture(\n          tile.getTileIndex(),\n          this.textureUrlPattern,\n        );\n        mat.uniforms.zoom.value = zoom;\n        mat.uniforms.isGlobe.value = isGlobe;\n        mat.uniforms.opacity.value = this.opacity;\n        (mat.uniforms.tileIndex.value as Vector3).set(tileIndeArray[0], tileIndeArray[1], tileIndeArray[2]);\n      },\n    });\n\n    this.remoteTileTextureManager = options.remoteTileTextureManager ?? new RemoteTileTextureManager();\n    this.textureUrlPattern = options.textureUrlPattern;\n  }\n}\n"],"names":["mercatorToTileIndex","position","zoom","strict","numberOfTilePerAxis","tileIndex","wgs84ToTileIndex","merCoord","MercatorCoordinate","getTileBoundsUnwrapped","map","z","bounds","nwMerc","maplibregl","seMerc","eps","nwTile","seTile","tileBoundsUnwrappedToTileList","tbu","allTileIndices","y","x","wrapTileIndex","nbTilePerAxis","tileIndexToMercatorCenterAndSize","ti","mercSize","mercCenter","isTileInViewport","mapcanvasWidth","mapCanvasHeight","canvasMarginW","canvasMarginH","mapCanvasWidthLowerBound","mapCanvasWidthUpperBound","mapCanvasHeightLowerBound","mapCanvasHeightUpperBound","screenPos","halfMercSize","mercTopLeft","mercTopRight","mercBottomLeft","mercBottomRight","clamp","range","value","pickImg","img","unitPosition","canvas","ctx","Tile","Mesh","geometry","material","__publicField","replaceMatrixScale","matrix","newScale","Vector3","quaternion","Quaternion","scale","newMatrix","Matrix4","scaleVector","defaultVertexShader","BaseShaderTiledLayer","id","options","v","Camera","Scene","PlaneGeometry","current","gl","WebGLRenderer","mapProjection","isGlobe","tileIndicesCandidates","tileMap","tile","wrappedTile","canvasWidth","canvasHeight","_map","_gl","tilesToAdd","usedTileMapPrevious","usedTileMapNew","element","tileID","opacity","altitude","TRANSPARENT_BLACK","Colormap","colormapDescription","_","i","hexColor","gradient","lowerKeyPointValue","upperKeyPointValue","lowerColor","upperColor","lowerToUpperKeyPointDistance","weightUpper","weightLower","size","horizontal","imageData","imageDataArray","valueStep","color","colormapCanvas","resolve","reject","blob","colormapImageBlob","numberOfLabels","round","labels","remainingLabels","labelStep","a","b","canvasEl","CanvasTexture","keyPointValues","colors","allKeyPointValuesAreNumbers","val","allColorsAreHex","scaling","pairs","currentMin","currentSpan","targetSpan","pairsClone","pair","pairClone","ordered","Color","colorObj","presureBlueWhiteRed","teal","cloudCoverTransparent","cream","lagoon","poison","twilight","redVelvet","ember","hot","spring","summer","autumn","winter","yiorrd","blackbody","viridis","inferno","magma","bathymetry","density","salinity","temperature","velocityBlue","turbo","turboColormapData","turboStop","ColormapDescriptionLibrary","RemoteTileTextureManager","TextureLoader","cacheSize","QuickLRU","_key","textureUrlPattern","tileIndexWrapped","textureURL","tempTexture","texture","_err","fragmentShader$3","DAY_MS","J1970","J2000","RAD","E","toJulian","timestamp","toDays","solarMeanAnomaly","d","eclipticLongitude","M","C","P","declination","l","rightAscension","sunCoords","L","dec","ra","computeSideralTimeComponent","day2YK","DaylightLayer","colormap","daysJ2K","sideralTimeComponent","RawShaderMaterial","GLSL3","fragmentShader","BackSide","_matrix","tileIndeArray","mat","date","fragmentShader$2","DummyGradientTiledLayer","fragmentShader$1","MultiChannelSeriesTiledLayer","texBeforeAfter","series","pos","seriesI","seriesNext","deltaBefore","deltaAfter","tileIndices","fetchingPromiseList","seriesIndexStart","seriesIndexEnd","lngLat","tileToPickUnstrict","tileIndexStrict","texturesBeforeAfter","textureBefore","textureAfter","textureUnitPosition","valuePixelBefore","valuePixelAfter","channels","valuePixelBeforeObj","valuePixelAfterObj","encodedValueBefore","encodedValueAfter","polynomialOffset","polynomialSlope","realWorldValueBefore","realWorldValueAfter","ratioAfter","TextureTiledLayer"],"mappings":"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"}